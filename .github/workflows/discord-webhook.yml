# File: .github/workflows/discord-webhook.yml
name: Discord Webhook (Push • PR • CI Summary)

on:
  push:
    branches: ["**"]
  pull_request:
    types: [opened, reopened, synchronize, closed]
  workflow_run:
    types: [completed]
    # NOTE: We intentionally do NOT filter by workflow name here so forks still trigger.
    # We filter by name inside the job against env.TARGET_CI_WORKFLOW.

permissions:
  contents: read
  pull-requests: read
  actions: read

env:
  TARGET_CI_WORKFLOW: CI   # Exact name of the CI workflow to summarize for workflow_run events.

jobs:
  discord_push:
    name: Post Push Summary
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - name: Post push embed to Discord
        uses: actions/github-script@v7
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          script: |
            const core = require('@actions/core');
            const {context, github} = require('@actions/github');

            // Guard: missing webhook
            if (!process.env.WEBHOOK_URL) {
              core.notice('DISCORD_WEBHOOK_URL not set; skipping Discord push notification.');
              return;
            }

            const colorY = 0xEAB308; // yellow
            const repoFull = `${context.repo.owner}/${context.repo.repo}`;
            const pld = context.payload;
            const branch = (pld.ref || '').replace('refs/heads/','');
            const pusher = pld.pusher?.name || pld.sender?.login || 'unknown';
            const compare = pld.compare || `https://github.com/${repoFull}/compare/${encodeURIComponent(pld.before)}...${encodeURIComponent(pld.after)}`;
            const commits = Array.isArray(pld.commits) ? pld.commits : [];
            const total = commits.length;

            // Build concise commit lines (max 5)
            const limit = 5;
            const items = commits.slice(0, limit).map(c => {
              const sha = (c.id || '').substring(0,7);
              const title = (c.message || '').split('\n')[0].trim();
              const trimmedTitle = title.length > 80 ? title.slice(0,77) + '…' : title;
              const author = c.author?.name || c.author?.username || 'unknown';
              return `[\`${sha}\`](${c.url}) — ${trimmedTitle} (_${author}_)`;
            });
            if (total > limit) items.push(`+${total - limit} more…`);

            const fields = [
              { name: 'Repo', value: `[${repoFull}](https://github.com/${repoFull})`, inline: true },
              { name: 'Branch', value: `\`${branch}\``, inline: true },
              { name: 'Pusher', value: pusher, inline: true },
            ];
            if (items.length) {
              const commitsBlock = items.join('\n');
              // Discord field value ≤ 1024
              const value = commitsBlock.length > 1024 ? commitsBlock.slice(0, 1021) + '…' : commitsBlock;
              fields.push({ name: `Commits (${total})`, value, inline: false });
            }

            const embed = {
              title: `Push to ${branch}`,
              url: compare,
              color: colorY,
              timestamp: new Date().toISOString(),
              author: {
                name: repoFull,
                url: `https://github.com/${repoFull}`
              },
              fields,
              footer: {
                text: `after ${String(pld.after || '').substring(0,7)} • ${new Date().toISOString()}`
              }
            };

            const res = await fetch(process.env.WEBHOOK_URL, {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({
                username: 'GitHub',
                embeds: [embed]
              })
            });
            if (!res.ok) {
              core.warning(`Discord webhook POST failed: ${res.status} ${res.statusText}`);
            }

  discord_pr:
    name: Post PR Summary
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Post PR embed to Discord
        uses: actions/github-script@v7
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          script: |
            const core = require('@actions/core');
            const {context, github} = require('@actions/github');

            if (!process.env.WEBHOOK_URL) {
              core.notice('DISCORD_WEBHOOK_URL not set; skipping Discord PR notification.');
              return;
            }

            const colorG = 0x22C55E; // green
            const colorR = 0xEF4444; // red
            const colorY = 0xEAB308; // yellow

            const pr = context.payload.pull_request;
            const number = pr.number;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Enrich via REST
            const {data: prData} = await github.rest.pulls.get({owner, repo, pull_number: number});
            const {data: reviews} = await github.rest.pulls.listReviews({owner, repo, pull_number: number, per_page: 100});
            const {data: labels}  = await github.rest.issues.listLabelsOnIssue({owner, repo, issue_number: number, per_page: 100});

            // Reviewers status (latest state per user)
            const latestByUser = new Map();
            for (const r of reviews) {
              latestByUser.set(r.user?.login || 'unknown', r.state || 'COMMENTED');
            }
            const states = { APPROVED: 0, CHANGES_REQUESTED: 0, COMMENTED: 0, DISMISSED: 0 };
            for (const s of latestByUser.values()) {
              if (states[s] !== undefined) states[s]++; else states.COMMENTED++;
            }
            const reviewersLine =
              `✅ ${states.APPROVED}  ❌ ${states.CHANGES_REQUESTED}  💬 ${states.COMMENTED}`;

            const labelNames = labels.map(l => l.name).join(', ') || '—';

            // Size
            const sizeLine = `+${prData.additions} / -${prData.deletions} • ${prData.changed_files} files`;

            // Color per action / merge state
            let color = colorY;
            let statusText = context.payload.action;
            if (context.payload.action === 'closed') {
              if (prData.merged) { color = colorG; statusText = 'merged'; }
              else { color = colorR; statusText = 'closed'; }
            } else if (context.payload.action === 'synchronize') {
              color = colorY;
            }

            const base = prData.base?.ref || 'base';
            const head = prData.head?.ref || 'head';
            const title = prData.title || '(no title)';
            const author = prData.user?.login || 'unknown';
            const htmlUrl = prData.html_url;

            const fields = [
              { name: 'Repo', value: `[${owner}/${repo}](https://github.com/${owner}/${repo})`, inline: true },
              { name: 'PR', value: `[#${number}](${htmlUrl})`, inline: true },
              { name: 'Author', value: author, inline: true },
              { name: 'Branches', value: `\`${base}\` ⇄ \`${head}\``, inline: true },
              { name: 'Size', value: sizeLine, inline: true },
              { name: 'Labels', value: labelNames.length > 1024 ? labelNames.slice(0,1021)+'…' : labelNames, inline: false },
              { name: 'Reviewers', value: reviewersLine, inline: true },
              { name: 'Status', value: statusText, inline: true },
            ];

            const embed = {
              title: `PR #${number}: ${title.length > 200 ? title.slice(0,197)+'…' : title}`,
              url: htmlUrl,
              color,
              timestamp: new Date().toISOString(),
              author: {
                name: `${owner}/${repo}`,
                url: `https://github.com/${owner}/${repo}`
              },
              fields,
              footer: {
                text: `${head}@${(prData.head?.sha || '').substring(0,7)} • ${new Date().toISOString()}`
              }
            };

            const res = await fetch(process.env.WEBHOOK_URL, {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ username: 'GitHub', embeds: [embed] })
            });
            if (!res.ok) {
              core.warning(`Discord webhook POST failed: ${res.status} ${res.statusText}`);
            }

  discord_ci_summary:
    name: Post CI Summary (workflow_run)
    if: github.event_name == 'workflow_run'
    runs-on: ubuntu-latest
    steps:
      - name: Post CI summary embed to Discord
        uses: actions/github-script@v7
        env:
          WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TARGET_CI_WORKFLOW: ${{ env.TARGET_CI_WORKFLOW }}
        with:
          script: |
            const core = require('@actions/core');
            const {context, github} = require('@actions/github');

            if (!process.env.WEBHOOK_URL) {
              core.notice('DISCORD_WEBHOOK_URL not set; skipping Discord CI summary.');
              return;
            }

            const wr = context.payload.workflow_run;
            const targetName = process.env.TARGET_CI_WORKFLOW || 'CI';
            if (!wr || wr.name !== targetName) {
              core.info(`workflow_run '${wr?.name}' != TARGET_CI_WORKFLOW '${targetName}'; skipping.`);
              return;
            }
            if (wr.status !== 'completed') {
              core.info(`workflow_run status is '${wr.status}', not 'completed'; skipping.`);
              return;
            }

            const colorG = 0x22C55E; // green
            const colorR = 0xEF4444; // red
            const colorY = 0xEAB308; // yellow
            const conclusion = wr.conclusion || 'unknown';

            let color = colorY;
            if (conclusion === 'success') color = colorG;
            else if (['failure','timed_out'].includes(conclusion)) color = colorR;

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Duration
            const started = new Date(wr.run_started_at || wr.created_at || wr.updated_at);
            const ended   = new Date(wr.updated_at || Date.now());
            const ms = Math.max(0, ended - started);
            const secs = Math.round(ms / 1000);
            const hh = String(Math.floor(secs/3600)).padStart(2,'0');
            const mm = String(Math.floor((secs%3600)/60)).padStart(2,'0');
            const ss = String(secs%60).padStart(2,'0');
            const duration = `${hh}:${mm}:${ss}`;

            // Attempt to find JUnit totals from artifacts (best-effort).
            // We list artifacts; if any name suggests junit/reports, we download the ZIP to /tmp/art.zip,
            // and try to extract simple counts by grepping XML after unzip. This may fail; we handle gracefully.
            let junitSummary = '';
            try {
              const {data: artifactsList} = await github.rest.actions.listWorkflowRunArtifacts({
                owner, repo, run_id: wr.id, per_page: 100
              });
              const cand = (artifactsList.artifacts || []).find(a =>
                /junit|report|test/i.test(a.name || '') && a.archive_download_url
              );
              if (cand) {
                // Download ZIP to file via the raw URL; octokit gives us an authenticated request
                const resp = await github.request('GET ' + cand.archive_download_url, {
                  owner, repo, headers: { accept: 'application/vnd.github+json' }
                });
                const fs = require('node:fs');
                const path = require('node:path');
                const cp = require('node:child_process');
                const tmpZip = '/tmp/artifact.zip';
                fs.writeFileSync(tmpZip, Buffer.from(resp.data));
                // Try to unzip to /tmp/artifacts
                const outDir = '/tmp/artifacts';
                try {
                  fs.mkdirSync(outDir, {recursive: true});
                  cp.execSync(`unzip -o ${tmpZip} -d ${outDir}`, {stdio: 'ignore'});
                  // Find first *.xml that looks like junit
                  const findXml = cp.execSync(`bash -lc "grep -ril --include='*.xml' -e '<testsuite' ${outDir} | head -n 1 || true"`).toString().trim();
                  if (findXml) {
                    const xml = fs.readFileSync(findXml, 'utf8');
                    // Naive parse: match tests, failures, errors, skipped at testsuite root
                    const m = xml.match(/<testsuite[^>]*\btests="(\d+)"[^>]*\bfailures="(\d+)"[^>]*\berrors="(\d+)"[^>]*\bskipped="(\d+)"/i)
                           || xml.match(/<testsuite[^>]*\btests="(\d+)"[^>]*\bfailures="(\d+)"[^>]*\bskipped="(\d+)"/i);
                    if (m) {
                      const tests = parseInt(m[1] || '0',10);
                      const failures = parseInt(m[2] || '0',10);
                      const errors = m.length >= 4 ? parseInt(m[3] || '0',10) : 0;
                      const skipped = m.length === 5 ? parseInt(m[4] || '0',10)
                                   : (m.length === 4 ? parseInt(m[3] || '0',10) : 0);
                      const failedTotal = failures + (Number.isFinite(errors) ? errors : 0);
                      const passed = Math.max(0, tests - failedTotal - skipped);
                      junitSummary = `tests: ${passed} ✔ / ${failedTotal} ✖ / ${skipped} ⚠`;
                    }
                  }
                } catch (e) {
                  // unzip/grep could fail; ignore
                }
              }
            } catch (e) {
              // Listing/downloading artifacts failed; ignore
            }

            const fields = [
              { name: 'Repo', value: `[${owner}/${repo}](https://github.com/${owner}/${repo})`, inline: true },
              { name: 'Workflow', value: wr.name, inline: true },
              { name: 'Run', value: `[#${wr.run_number}](${wr.html_url})`, inline: true },
              { name: 'Conclusion', value: conclusion, inline: true },
              { name: 'Duration', value: duration, inline: true },
              { name: 'Branch', value: `\`${wr.head_branch}\``, inline: true },
              { name: 'Commit', value: `[${(wr.head_sha||'').substring(0,7)}](https://github.com/${owner}/${repo}/commit/${wr.head_sha})`, inline: true },
              { name: 'Actor', value: wr.actor?.login || 'unknown', inline: true },
            ];
            if (junitSummary) {
              fields.push({ name: 'CI', value: junitSummary, inline: false });
            }

            const embed = {
              title: `CI: ${conclusion} • ${wr.name}`,
              url: wr.html_url,
              color,
              timestamp: new Date().toISOString(),
              author: {
                name: `${owner}/${repo}`,
                url: `https://github.com/${owner}/${repo}/actions`
              },
              fields,
              footer: {
                text: `${wr.head_branch}@${(wr.head_sha||'').substring(0,7)} • ${new Date().toISOString()}`
              }
            };

            const res = await fetch(process.env.WEBHOOK_URL, {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ username: 'GitHub', embeds: [embed] })
            });
            if (!res.ok) {
              core.warning(`Discord webhook POST failed: ${res.status} ${res.statusText}`);
            }
